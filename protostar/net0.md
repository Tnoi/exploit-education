## Protostar - net0 ##
El programa /opt/protostar/bin/net0 se lanza cuando se enciende la máquina. Al ejecutar el comando `strace /opt/protostar/bin/net0` podemos ver lo siguiente:
``` bash
...
open("/opt/protostar/run/net0.pid", O_RDWR|O_CREAT|O_TRUNC, 0700) = 3
setgroups32(1, [999]) = 0
setresgid32(999, 999, 999) = 0
setresuid32(999, 999, 999) = 0
clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e96728) = 1910
exit_group(0)
```
Habre el fichero `/opt/protostar/run/net0.pid`, hace un *drop privileges*, y luego, crea un clon y hace un *exit*.

Para ver que hace el clon creado, podemos ejecutar el comando `strace -f /opt/protostar/bin/net0`:
``` bash
...
clone(Process 1919 attached
child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e96728) = 1919
[pid  1918] exit_group(0)               = ?
setsid()                                = 1919
chdir("/")                              = 0
open("/dev/null", O_RDWR)               = 4
fstat64(4, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
dup2(4, 0)                              = 0
dup2(4, 1)                              = 1
dup2(4, 2)                              = 2
close(4)                                = 0
write(3, "1919\n", 5)                   = 5
close(3)                                = 0
socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 3
setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
bind(3, {sa_family=AF_INET, sin_port=htons(2999), sin_addr=inet_addr("0.0.0.0")}, 16) = -1 EADDRINUSE (Address already in use)
write(2, "serve_forever: unable to bind():"..., 56) = 56
exit_group(6)
```
El clon lo que hace es abrir el fichero `/dev/null`, redirigir STDIO, STDOUT y STDERR a `/dev/null`, cerrarlo, escribir su PID en el fichero que ha abierto antes (`/opt/protostar/run/net0.pid`), cerrar dicho fichero y abrir un socket e intentar bindearlo a la dirección 127.0.0.1:2999, pero falla, porque el proceso ya esta en marcha.
Si matamos al proceso (net0) actual y volvemos a lanzar el mismo comando:
```bash
...
bind(3, {sa_family=AF_INET, sin_port=htons(2999), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
listen(3, 10)                           = 0
accept(3,
```
En este caso al lanzar el proceso como nuevo, si que puede crear el socket en la dirección 127.0.0.1:2999. A partir de este momento todas las conexiones a dicha dirección, crearan un clon del proceso que lanzará la función run.

Al conectarnos con `nc 127.0.0.1 2999` vemos como el proceso nos contesta:
``` bash
root@protostar:/home/user# nc 127.0.0.1 2999
Please send '1890056372' as a little endian 32bit int

```
Y si prestamos atencion al terminal donde teniemos nuestro proceso esperando las conexiones con el `accept`, podemos ver la conexión:
``` bash
accept(3, {sa_family=AF_INET, sin_port=htons(59609), sin_addr=inet_addr("127.0.0.1")}, [16]) = 4
clone(Process 1930 attached
child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e96728) = 1930
[pid  1924] close(4)                    = 0
[pid  1924] accept(3,  <unfinished ...>
[pid  1930] close(3)                    = 0
[pid  1930] dup2(4, 0)                  = 0
[pid  1930] dup2(4, 1)                  = 1
[pid  1930] dup2(4, 2)                  = 2
[pid  1930] time(NULL)                  = 1555598520
[pid  1930] write(1, "Please send '1890056372' as a li"..., 54) = 54
[pid  1930] read(0,
```
Como la función `run` usa un fgets, el proceso se queda esperando a que el cliente le envia los datos para avanzar su ejecución. Si con el `nc` enviamos algo:
```bash
root@protostar:/home/user# nc 127.0.0.1 2999
Please send '1890056372' as a little endian 32bit int
0
I\'m sorry, you sent 544501582 instead
root@protostar:/home/user#
```
el proceso continua:
```bash
[pid  1938] read(0, "hell", 4)          = 4
[pid  1938] write(1, "I'm sorry, you sent 1819043176 i"..., 39) = 39
[pid  1938] exit_group(39)              = ?
Process 1938 detached
<... accept resumed> 0xbffff798, [16])  = ? ERESTARTSYS (To be restarted)
--- SIGCHLD (Child exited) @ 0 (0) ---
wait4(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 39}], 0, NULL) = 1938
sigreturn()                             = ? (mask now [])
accept(3,
```
Ejecuta la función `run`, el clon hace un `exit` y el padre se queda esperando más conexiones.

Para poder enviar los datos que nos pide tenemos que recurrir a un pequeño truco; utilizar el comando `cat` como entrada del `nc`:
```bash
root@protostar:/home/user# echo -e "`cat -`" | nc 127.0.0.1 2999
Please send '1787795217' as a little endian 32bit int

```
Con esto ya podemos enviar valores en hexadecimal de la forma `\x`. Utilizamos python para averiguar como es el número que nos piden:
```python
>>> import struct
>>> struct.pack('I', 1787795217)
'\x11\x97\x8fj'
```
Y lo insertamos en la terminal, pulsamos enter, y luego `ctrl + d` para decirle al `cat` que envie:
```bash
root@protostar:/home/user# echo -e "`cat -`" | nc 127.0.0.1 2999
Please send '1787795217' as a little endian 32bit int
\x11\x97\x8fj
Thank you sir/madam
```
